#!/usr/bin/env python3

from sys import argv
import re

class OpcodeEnum:
    def __init__(self, out):
        self.out = out

    def start(self):
        self.out.write('// generated by gen_code.py\n')
        self.out.write('#pragma once\n')
        self.out.write('namespace amyinorbit::compass {\n')
        self.out.write('    enum class Opcode {\n')

    def instruction(self, mnemonic, instruction, operands, stack, comments=None):
        self.out.write('        %s = 0x%02x,\n' % (mnemonic, instruction))

    def end(self):
        self.out.write('    };\n')
        self.out.write('}\n')

class AssemblyTable:
    def __init__(self, out):
        self.out = out

    def start(self):
        self.out.write('// generated by gen_code.py\n')
        self.out.write('#include <compass/bytecode.hpp>\n')
        self.out.write('namespace amyinorbit::compass {\n')

        self.out.write('    static const map<string, Opcode> keywords = {\n')

    def instruction(self, mnemonic, instruction, operands, stack, comments=None):
        self.out.write('        {\"%s\", Opcode::%s},\n' % (mnemonic, mnemonic))

    def end(self):
        self.out.write('    };\n')
        self.out.write('}\n')

class XMacro:
    def __init__(self, out):
        self.out = out

    def start(self):
        self.out.write('// generated by gen_code.py\n')
        self.out.write('#pragma once\n')
        self.out.write('\n\n')

    def instruction(self, mnemonic, instruction, operands, stack, comments=None):
        self.out.write(
            'OPCODE(%-10s, 0x%02x, %+3d, %+3d)' % (mnemonic, instruction, operands, stack))
        if comments:
            self.out.write(' // %s' % comments)
        self.out.write('\n')

    def end(self):
        self.out.write('\n')

def main():
    if len(argv) != 4:
        print('gen_code [generator] [opcode_defs] [out_file]')
        return

    _, gen, in_fname, out_fname = argv

    p = re.compile(r'\s{2,}')

    writers = {
        'assembler': AssemblyTable,
        'x-macro': XMacro,
        'enum': OpcodeEnum,
    }

    if not gen in writers:
        print('invalid generator name')
        return


    with open(in_fname, 'r') as input, open(out_fname, 'w') as out:
        gen = writers[gen](out)
        gen.start()

        state = 0
        headers = dict()
        instr = 0
        for line in (l.strip() for l in input):
            if not len(line): continue

            if state == 0:

                fields = p.split(line)
                for i, f in enumerate(fields): headers[f] = i
                if not 'code' in headers: exit('missing column in def file: code')
                if not 'stack' in headers: exit('missing column in def file: stack')
                if not 'operands' in headers: exit('missing column in def file: operands')
                state = 1

            elif state == 1:
                if not line.startswith('======'):
                    exit('missing separator')
                state = 2

            elif state == 2:
                fields = p.split(line)

                code = fields[headers['code']]
                ops = int(fields[headers['operands']])
                stack = int(fields[headers['stack']])

                if 'comments' in headers and len(fields) > headers['comments']:
                    gen.instruction(code, instr, ops, stack, fields[headers['comments']])
                else:
                    gen.instruction(code, instr, ops, stack)
                instr += 1
        gen.end()

if __name__ == '__main__':
    main()
