# Story Engine Bytecode Operations

The story engine runs a stack-based VM interpreter. There is no garbage collection and no heap allocations, most things are strings since we are dealing with prose. Strings are pooled in a story. When the story is started, the room, object and link structure is copied from the "prototype" one, hence bytecode only acts on a copy (allows re-starting the story without having a complex undo/reset mechanism).

Verbs are basically functions. Writing "boop the button" really should translate to something like `boop(button, context)`, or in the C++ code really `invoke_verb("boop", buttonObj, context)`.

Bytecode will be very limited at first, and we can add to it as we go. Essential things that should be doable are:
 - call built-in functions. Say?
 - unlocking a link
 - changing a room description
 - changing an object's state. [not clear yet how we should represent state, they are a bit arbitrary. maybe a string `state` variable]
 - check the state of an object
 - check if a room has been visited
 - check a room's description?
 - get the adjacent rooms?


## Bytecode operations:

push_str        [...] -> [string_id]

lock_room       [..., string_id] -> [...]
unlock_room     [..., string_id] -> [...]

load_obj        [..., string_id] -> [..., obj_ptr]
load_this       [..., string_id] -> [..., obj_ptr]
load_room       [..., string_id] -> [..., room_ptr]

load_desc       [..., obj_ptr] -> [..., string_id]
store_desc      [..., obj_ptr, string_id] -> [...]

say             [..., string_id] -> [...]
go              [..., room_ptr] -> [...]

load_status     [..., obj_ptr] -> [..., string_id]
store_status    [..., obj_ptr, string_id] -> [...]

load_visit      [..., room_ptr] -> [..., bool]

jump
jump_if

